"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = IceEvents;

var _eventEmitter = _interopRequireDefault(require("event-emitter"));

var _smartMixin = _interopRequireDefault(require("smart-mixin"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mixinProto = (0, _smartMixin.default)({
  // lifecycle stuff is as you'd expect
  componentDidMount: _smartMixin.default.MANY,
  componentWillMount: _smartMixin.default.MANY,
  componentWillReceiveProps: _smartMixin.default.MANY,
  shouldComponentUpdate: _smartMixin.default.ONCE,
  componentWillUpdate: _smartMixin.default.MANY,
  componentDidUpdate: _smartMixin.default.MANY,
  componentWillUnmount: _smartMixin.default.MANY,
  getChildContext: _smartMixin.default.MANY_MERGED
});
var win;

if (typeof window !== 'undefined') {
  win = window;
} else if (typeof global !== 'undefined') {
  win = global;
} else if (typeof self !== 'undefined') {
  win = self;
} else {
  win = {};
} // SingleTon


var instance = win.IceEventsInstance = win.IceEventsInstance || (0, _eventEmitter.default)();

IceEvents.on = function (eventName, eventListener) {
  instance.on(eventName, eventListener);
  return eventListener;
};

IceEvents.once = function (eventName, eventListener) {
  instance.once(eventName, eventListener);
  return eventListener;
};

IceEvents.off = instance.off.bind(instance);
IceEvents.emit = instance.emit.bind(instance); // decorator

function IceEvents(classDeclaration) {
  classDeclaration.prototype.iceEventsListener = []; // 这里放了组件所有监听的事件对象

  var prototypeMethods = {
    on: function on(eventName, eventListener) {
      this.iceEventsListener.push({
        eventName: eventName,
        eventListener: eventListener
      });
      return IceEvents.on(eventName, eventListener);
    },
    once: function once(eventName, eventListener) {
      this.iceEventsListener.push({
        eventName: eventName,
        eventListener: eventListener
      });
      return IceEvents.once(eventName, eventListener);
    },
    emit: instance.emit.bind(instance),
    off: instance.off.bind(instance),
    componentWillUnmount: function componentWillUnmount() {
      this.iceEventsListener.forEach(function (eventObj) {
        IceEvents.off(eventObj.eventName, eventObj.eventListener);
      });
    }
  };
  return mixinProto(classDeclaration.prototype, prototypeMethods);
}